import { ref, computed, watch } from 'vue'
import api from '../../api.js'
import MultiLabelSelector from '../../MultiLabelSelector.vue'
import RuleItem from '../../RuleItem.vue'
import CreateRuleDialog from '../../shared/CreateRuleDialog.vue'
import { matchesRule, applyRulesWithDetails } from '../../../utils/ruleMatcher.js'
import { useRulesReview } from '../../shared/RulesReviewMixin.js'

export default {
  name: 'AutoGeneratedRulesReview',
  components: {
    MultiLabelSelector,
    RuleItem,
    CreateRuleDialog
  },
  props: {
    autoRules: Object,
    ruleMatches: {
      type: Map,
      default: () => new Map()
    },
    transactions: Array,
    accounts: Array
  },
  emits: ['rule-created'],
  setup(props, { emit }) {
    // Use shared rules review functionality
    const {
      showSnack,
      snackMessage,
      getCategoryName,
      showSnackMessage,
      toggleExpanded: sharedToggleExpanded,
      startEditing: sharedStartEditing,
      saveEdit: sharedSaveEdit,
      cancelEdit: sharedCancelEdit,
      deleteRule: sharedDeleteRule
    } = useRulesReview()

    // Existing rules state
    const expandedRules = ref(new Set())
    const editingRule = ref(null)

    // Auto rules state
    const expandedAutoRules = ref(new Set())
    const editingAutoRule = ref(null)
    const ruleFrequencies = ref(new Map())
    const ruleExplanations = ref(new Map())

    // Create rule dialog state
    const showCreateRuleDialog = ref(false)
    const createRuleTransaction = ref(null)
    const createRuleData = ref({
      match_type: 'contains',
      pattern: '',
      category: '',
      labels: []
    })

    // Computed properties

    const effectiveAutoRules = computed(() => {
      if (!props.autoRules || !props.autoRules.rules) return []
      const rules = props.autoRules.rules
        .filter(rule => !rule.applied)
        .map(rule => {
          const transactions = props.ruleMatches.get(rule.id) || []
          const hasInMap = props.ruleMatches.has(rule.id)
          console.log(`effectiveAutoRules: Rule ${rule.id} (${rule.pattern}) has ${transactions.length} transactions, exists in map: ${hasInMap}`)
          return {
            ...rule,
            transactions
          }
        })
      
      console.log('effectiveAutoRules: Total rules with transactions:', rules.length)
      return rules
    })

    // Helper functions (getCategoryName is now provided by shared mixin)

    function getAccountName(accountId) {
      const account = props.accounts.find(a => a.id === accountId)
      return account ? account.name : 'Unknown Account'
    }

    function formatAmount(amount) {
      if (amount === null || amount === undefined || isNaN(amount)) return '$0.00'
      return `$${Number(amount).toFixed(2)}`
    }

    function formatDate(dateString) {
      if (!dateString) return 'Unknown'
      const date = new Date(dateString)
      if (isNaN(date.getTime())) return 'Unknown'
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      })
    }

    // Existing rules functions (using shared functionality)
    function toggleExpanded(rule) {
      sharedToggleExpanded(expandedRules, rule)
    }

    function startEditing(rule) {
      sharedStartEditing(editingRule, rule)
    }

    async function saveEdit(rule, editData) {
      await sharedSaveEdit(rule, editData, editingRule, emit)
    }

    function cancelEdit() {
      sharedCancelEdit(editingRule)
    }

    async function deleteRule(rule) {
      await sharedDeleteRule(rule, emit)
    }

    // Auto rules functions
    function toggleAutoRuleExpanded(rule) {
      const ruleId = rule.id
      if (expandedAutoRules.value.has(ruleId)) {
        expandedAutoRules.value.delete(ruleId)
      } else {
        expandedAutoRules.value.add(ruleId)
      }
    }

    function startEditingAutoRule(rule) {
      editingAutoRule.value = rule.id
    }

    async function saveAutoRuleEdit(rule, editData) {
      try {
        // For auto rules, we need to create a new rule
        const newRule = await api.createRule(editData)
        editingAutoRule.value = null
        showSnackMessage('Rule created successfully')
        // Remove from auto rules list
        removeAutoRule(rule.id)
        // Emit event to parent to track the new rule
        emit('rule-created', newRule)
      } catch (error) {
        console.error('Error creating rule:', error)
        showSnackMessage('Error creating rule: ' + error.message)
      }
    }

    function cancelAutoRuleEdit() {
      editingAutoRule.value = null
    }

    function removeAutoRule(rule) {
      // Remove from auto rules list (this is just UI state)
      const ruleIndex = props.autoRules.rules.findIndex(r => r.id === rule.id)
      if (ruleIndex !== -1) {
        props.autoRules.rules.splice(ruleIndex, 1)
      }
    }





    function getPreviewCount(ruleId) {
      return props.ruleMatches.get(ruleId)?.length || 0
    }

    function getPreviewMatches(ruleId) {
      return (props.ruleMatches.get(ruleId) || []).slice(0, 3)
    }

    function getExistingRulePreviewCount(ruleId) {
      return props.ruleMatches.get(ruleId)?.length || 0
    }

    function getExistingRulePreviewMatches(ruleId) {
      return (props.ruleMatches.get(ruleId) || []).slice(0, 3)
    }

    function getExistingRuleSingleMatch(ruleId) {
      return (props.ruleMatches.get(ruleId) || []).slice(0, 1)
    }

    function getSinglePreviewMatch(ruleId) {
      return (props.ruleMatches.get(ruleId) || []).slice(0, 1)
    }

    // Create rule from transaction
    function createRuleFromTransaction(transaction, rule) {
      createRuleTransaction.value = transaction
      createRuleData.value = {
        match_type: 'contains',
        pattern: transaction.name,
        category: rule.category,
        labels: []
      }
      showCreateRuleDialog.value = true
    }

    function handleCreateRuleSave(ruleData) {
      try {
        console.log('handleCreateRuleSave: Creating rule in memory:', ruleData)
        
        // Create a rule object in memory (don't send to backend yet)
        const newRule = {
          id: `temp_rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          ...ruleData,
          priority: 1000, // High priority for user-created rules
          enabled: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          isTemporary: true // Flag to indicate this is not yet saved to backend
        }
        
        console.log('handleCreateRuleSave: Created rule in memory:', newRule)
        showCreateRuleDialog.value = false
        showSnackMessage('Rule created successfully')
        // Emit event to parent to track the new rule
        emit('rule-created', newRule)
      } catch (error) {
        console.error('Error creating rule:', error)
        showSnackMessage('Error creating rule: ' + error.message)
      }
    }

    function saveNewRule() {
      // This method is kept for backward compatibility but now delegates to handleCreateRuleSave
      handleCreateRuleSave(createRuleData.value)
    }

    function cancelCreateRule() {
      showCreateRuleDialog.value = false
      createRuleTransaction.value = null
      createRuleData.value = {
        match_type: 'contains',
        pattern: '',
        category: '',
        labels: []
      }
    }

    // showSnackMessage is now provided by the shared mixin

    // Initialize rule frequencies and explanations
    function initializeRuleData() {
      console.log('initializeRuleData: Called with autoRules:', !!props.autoRules)
      if (props.autoRules && props.autoRules.rules) {
        console.log('initializeRuleData: Processing', props.autoRules.rules.length, 'rules')
        props.autoRules.rules.forEach(rule => {
          ruleFrequencies.value.set(rule.id, rule.frequency || 0)
          ruleExplanations.value.set(rule.id, rule.explain || '')
        })
        
        // Rule matches are now provided via centralized matching
      }
    }

    // Watch for changes in autoRules and initialize data
    watch(() => props.autoRules, () => {
      initializeRuleData()
    }, { immediate: true })

    return {
      // State
      expandedRules,
      editingRule,
      expandedAutoRules,
      editingAutoRule,
      ruleFrequencies,
      ruleExplanations,
      showCreateRuleDialog,
      createRuleTransaction,
      createRuleData,
      showSnack,
      snackMessage,
      
      // Computed
      effectiveAutoRules,
      
      // Methods
      getCategoryName,
      getAccountName,
      formatAmount,
      formatDate,
      toggleExpanded,
      startEditing,
      saveEdit,
      cancelEdit,
      deleteRule,
      toggleAutoRuleExpanded,
      startEditingAutoRule,
      saveAutoRuleEdit,
      cancelAutoRuleEdit,
      removeAutoRule,
      getPreviewCount,
      getPreviewMatches,
      getExistingRulePreviewCount,
      getExistingRulePreviewMatches,
      getExistingRuleSingleMatch,
      getSinglePreviewMatch,
      createRuleFromTransaction,
      handleCreateRuleSave,
      saveNewRule,
      cancelCreateRule,
      showSnackMessage,
      initializeRuleData
    }
  }
}
