import { ref, computed } from 'vue'
import api from '../api.js'
import { CATEGORY_STEPS, CATEGORY_NAMES } from '../../config/categories.js'
import AutoGeneratedRulesReview from '../RulesReview/AutoGeneratedRulesReview/AutoGeneratedRulesReview.vue'
import PreexistingRulesReview from '../RulesReview/PreexistingRulesReview/PreexistingRulesReview.vue'
import NewRulesReview from '../RulesReview/NewRulesReview/NewRulesReview.vue'
import TransactionReview from '../TransactionReview/TransactionReview.vue'
import { getUnmatchedTransactions, applyRulesWithDetails, getTransactionsForRule } from '../../utils/ruleMatcher.js'

export default {
  name: 'ImportWizard',
  components: {
    AutoGeneratedRulesReview,
    PreexistingRulesReview,
    NewRulesReview,
    TransactionReview
  },
  props: {
    accounts: Array
  },
  emits: ['refresh-accounts', 'import-complete'],
  setup(props, { emit }) {
    const newAccount = ref('')
    const step = ref(1) // 1: file selection, 2: account assignment, 3: rules review, 4: transaction review, 5: complete
    const creating = ref(false)
    const createError = ref('')
    const createForm = ref(null)
    const editingAccount = ref(null)
    const editAccountName = ref('')
    const editError = ref('')
    const updating = ref(false)
    const deleteDialog = ref(false)
    const accountToDelete = ref(null)
    const deleting = ref(false)
    const deleteError = ref('')
    const files = ref([])
    const fileAnalysis = ref([])
    const filesByAccount = ref(new Map()) // Map<accountId, File[]>
    const previewsByAccount = ref(new Map()) // Map<accountId, preview[]>
    const usedRules = ref([])
    const autoRules = ref(null)
    const newRules = ref([])
    const allTransactions = ref([])
    
    // Centralized rule matching results
    const existingRuleMatches = ref(new Map())
    const newRuleMatches = ref(new Map())
    const autoRuleMatches = ref(new Map())
    const isDragOver = ref(false)
    const processing = ref(false)
    const currentCategoryStep = ref(0) // 0: fixed, 1: investments, 2: guilt_free, 3: short_term
    const categorySteps = CATEGORY_STEPS
    const categoryStepNames = CATEGORY_STEPS.map(step => CATEGORY_NAMES[step])

    // Validation rules for account names
    const accountNameRules = [
      v => !!v || 'Account name is required',
      v => (v && v.trim().length >= 2) || 'Account name must be at least 2 characters',
      v => (v && v.trim().length <= 50) || 'Account name must be less than 50 characters'
    ]

    const totalFiles = computed(() => files.value.length)

    const totalTransactions = computed(() => {
      let total = 0
      for (const preview of previewsByAccount.value.values()) {
        total += preview.length
      }
      return total
    })

    const currentCategoryTransactions = computed(() => {
      const allTransactions = []
      for (const preview of previewsByAccount.value.values()) {
        allTransactions.push(...preview)
      }
      return allTransactions.filter(tx => 
        !tx.ignore && 
        tx.category === categorySteps[currentCategoryStep.value]
      )
    })

    const hasMoreCategories = computed(() => {
      return currentCategoryStep.value < categorySteps.length - 1
    })

    const hasPreviousCategories = computed(() => {
      return currentCategoryStep.value > 0
    })

    const allFilesAssigned = computed(() => {
      return fileAnalysis.value.every((analysis, index) => {
        return getCurrentAccountId(index) !== null
      })
    })

    function getCurrentAccountId(fileIndex) {
      const file = files.value[fileIndex]
      for (const [accountId, accountFiles] of filesByAccount.value) {
        if (accountFiles.includes(file)) {
          return accountId
        }
      }
      return null
    }

    function getAccountName(accountId) {
      const account = props.accounts.find(a => a.id === accountId)
      return account ? account.name : 'Unknown Account'
    }

    function getFileFormat(filename) {
      const ext = filename.toLowerCase().split('.').pop()
      switch (ext) {
        case 'csv':
          return 'CSV'
        case 'qfx':
        case 'ofx':
          return 'QFX'
        default:
          return ext.toUpperCase()
      }
    }

    async function addAccount() {
      if (!newAccount.value.trim()) return
      
      creating.value = true
      createError.value = ''
      
      try {
        await api.createAccount(newAccount.value.trim())
        newAccount.value = ''
        // Reset form validation state
        if (createForm.value) {
          createForm.value.resetValidation()
        }
        await emit('refresh-accounts')
      } catch (error) {
        createError.value = error.response?.data?.error || 'Failed to create account'
      } finally {
        creating.value = false
      }
    }

    function startEdit(account) {
      editingAccount.value = account.id
      editAccountName.value = account.name
      editError.value = ''
    }

    function cancelEdit() {
      editingAccount.value = null
      editAccountName.value = ''
      editError.value = ''
    }

    async function saveAccount(accountId) {
      if (!editAccountName.value.trim()) return
      
      updating.value = true
      editError.value = ''
      
      try {
        await api.updateAccount(accountId, editAccountName.value.trim())
        editingAccount.value = null
        editAccountName.value = ''
        await emit('refresh-accounts')
      } catch (error) {
        editError.value = error.response?.data?.error || 'Failed to update account'
      } finally {
        updating.value = false
      }
    }

    function confirmDelete(account) {
      accountToDelete.value = account
      deleteError.value = ''
      deleteDialog.value = true
    }

    async function deleteAccount() {
      if (!accountToDelete.value) return
      
      deleting.value = true
      deleteError.value = ''
      
      try {
        await api.deleteAccount(accountToDelete.value.id)
        deleteDialog.value = false
        accountToDelete.value = null
        await emit('refresh-accounts')
      } catch (error) {
        deleteError.value = error.response?.data?.error || 'Failed to delete account'
      } finally {
        deleting.value = false
      }
    }

    function formatDate(dateString) {
      if (!dateString) return 'Unknown'
      const date = new Date(dateString)
      if (isNaN(date.getTime())) return 'Unknown'
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      })
    }

    function handleDragOver(e) {
      e.preventDefault()
      isDragOver.value = true
    }

    function handleDragLeave(e) {
      e.preventDefault()
      isDragOver.value = false
    }

    function handleDrop(e) {
      e.preventDefault()
      isDragOver.value = false
      
      const droppedFiles = Array.from(e.dataTransfer.files).filter(file => {
        const filename = file.name.toLowerCase()
        return filename.endsWith('.csv') || filename.endsWith('.qfx') || filename.endsWith('.ofx')
      })
      
      if (droppedFiles.length === 0) {
        alert('Please drop a CSV or QFX file only')
        return
      }
      
      if (droppedFiles.length > 1) {
        alert('Please drop only one file at a time')
        return
      }
      
      files.value = [droppedFiles[0]] // Only keep the first file
      analyzeFiles()
    }

    function handleFileSelect(e) {
      const selectedFiles = Array.from(e.target.files).filter(file => {
        const filename = file.name.toLowerCase()
        return filename.endsWith('.csv') || filename.endsWith('.qfx') || filename.endsWith('.ofx')
      })
      
      if (selectedFiles.length === 0) {
        alert('Please select a CSV or QFX file only')
        return
      }
      
      if (selectedFiles.length > 1) {
        alert('Please select only one file at a time')
        return
      }
      
      files.value = [selectedFiles[0]] // Only keep the first file
      analyzeFiles()
    }

    async function analyzeFiles() {
      if (files.value.length === 0) return
      
      processing.value = true
      try {
        const result = await api.analyzeFiles(files.value)
        fileAnalysis.value = result.analysis
        
        // Auto-assign file based on suggestions
        filesByAccount.value.clear()
        const analysis = fileAnalysis.value[0] // Only one file now
        const file = files.value[0] // Only one file now
        if (file && analysis) {
          const accountId = analysis.suggestedAccount?.id || props.accounts[0]?.id
          if (accountId) {
            filesByAccount.value.set(accountId, [file])
          }
        }
        
        step.value = 2
      } catch (error) {
        console.error('Error analyzing files:', error)
        alert('Error analyzing files: ' + error.message)
      } finally {
        processing.value = false
      }
    }

    function removeFile(fileIndex) {
      files.value = []
      fileAnalysis.value = []
      filesByAccount.value.clear()
    }

    function reassignFile(fileIndex, newAccountId) {
      const file = files.value[fileIndex]
      
      // Clear current assignment and assign to new account
      filesByAccount.value.clear()
      filesByAccount.value.set(newAccountId, [file])
    }

    async function processAllFiles() {
      if (filesByAccount.value.size === 0) return
      
      processing.value = true
      previewsByAccount.value.clear()
      usedRules.value = []
      
      try {
        // Process the single file
        for (const [accountId, accountFiles] of filesByAccount.value) {
          const file = accountFiles[0] // Only one file now
          try {
            // Import transactions without categorization
            const res = await api.importCSV(accountId, file)
            const rawTransactions = res.preview || []
            
            // Load existing rules from backend
            const existingRules = await api.getRules()
            
            // Apply rules to transactions using centralized logic
            const ruleMatchingResult = applyRulesWithDetails(rawTransactions, existingRules)
            const categorizedTransactions = ruleMatchingResult.categorizedTransactions
            
            // Get unmatched transactions for auto rule generation
            const unmatchedTransactions = getUnmatchedTransactions(rawTransactions, existingRules)
            
            // Generate auto rules for unmatched transactions
            // Send categorized transactions so auto rule generator can learn from existing patterns
            let autoRulesResult = null
            if (unmatchedTransactions.length >= 5) {
              try {
                autoRulesResult = await api.generateAutoRules(categorizedTransactions)
              } catch (error) {
                console.warn('Auto rule generation failed:', error)
              }
            }
            
            // Store the categorized transactions
            previewsByAccount.value.set(accountId, categorizedTransactions)
            
            // Store the existing rules (without transactions - they'll come from centralized matching)
            usedRules.value = existingRules
            
            // Store auto rules
            autoRules.value = autoRulesResult
            
            // Store raw transactions for AutoGeneratedRulesReview to work with
            allTransactions.value = rawTransactions
            
            // Compute all rule matches with proper priority handling
            computeAllRuleMatches()
            
            // Filter rules to only show those with matches
            usedRules.value = usedRules.value.filter(rule => {
              const matches = existingRuleMatches.value.get(rule.id) || []
              return matches.length > 0
            })
            
            if (autoRules.value?.rules) {
              autoRules.value.rules = autoRules.value.rules.filter(rule => {
                const matches = autoRuleMatches.value.get(rule.id) || []
                return matches.length > 0
              })
            }
            
            // Note: newRules.value starts empty, so no filtering needed here
          } catch (error) {
            console.error(`Error processing file ${file.name}:`, error)
            alert(`Error processing file ${file.name}: ${error.message}`)
          }
        }
        
        // Go to combined rules review step
        step.value = 3 // Combined rules review step
        currentCategoryStep.value = 0
      } catch (error) {
        console.error('Error processing file:', error)
        alert('Error processing file: ' + error.message)
      } finally {
        processing.value = false
      }
    }

    function nextCategory() {
      if (hasMoreCategories.value) {
        currentCategoryStep.value++
      }
    }

    function previousCategory() {
      if (hasPreviousCategories.value) {
        currentCategoryStep.value--
      }
    }

    async function commitAllImports() {
      processing.value = true
      
      try {
        let totalImported = 0
        
        for (const [accountId, preview] of previewsByAccount.value) {
          const itemsToImport = preview.filter(x => !x.ignore)
          if (itemsToImport.length > 0) {
            await api.commitImport(itemsToImport)
            totalImported += itemsToImport.length
          }
        }
        
        // Clear everything
        files.value = []
        fileAnalysis.value = []
        filesByAccount.value.clear()
        previewsByAccount.value.clear()
        step.value = 5
        
        alert(`Import complete! ${totalImported} transactions imported.`)
        
        // Emit import complete event
        emit('import-complete')
        
        // Reset after a delay
        setTimeout(() => {
          step.value = 1
          currentCategoryStep.value = 0
        }, 2000)
        
      } catch (error) {
        console.error('Error committing imports:', error)
        alert('Error committing imports: ' + error.message)
      } finally {
        processing.value = false
      }
    }

    function resetImport() {
      files.value = []
      fileAnalysis.value = []
      filesByAccount.value.clear()
      previewsByAccount.value.clear()
      usedRules.value = []
      newRules.value = []
      step.value = 1
      currentCategoryStep.value = 0
    }

    function handleRulesCommit() {
      commitAllImports()
    }

    function handleRulesCancel() {
      resetImport()
    }

    function handleRefreshRules() {
      // Refresh rules by reprocessing the import
      processAllFiles()
    }

    function handleRulesRefresh() {
      // Handle rules refresh from PreexistingRulesReview component
      // Recompute all rule matches to refresh UI when rules are edited
      computeAllRuleMatches()
    }

    function addNewRule(rule) {
      console.log('addNewRule: Received rule (temporary):', rule)
      
      // Validate that the rule matches at least one transaction
      const testMatches = applyRulesWithDetails(allTransactions.value, [rule])
      const matchingTransactions = testMatches.ruleMatches.get(rule.id) || []
      
      if (matchingTransactions.length === 0) {
        alert('This rule does not match any of the currently imported transactions. Please adjust the pattern or create the rule later.')
        return
      }
      
      const newRuleData = {
        ...rule,
        created_during_import: true,
        hasChanges: true, // Mark as having changes to persist
        isNew: true // Mark as new rule
      }
      
      console.log('addNewRule: Adding rule to newRules array:', newRuleData)
      newRules.value.push(newRuleData)
      
      // Recompute all rule matches with proper priority handling
      computeAllRuleMatches()
      
      // Filter new rules to only keep those with matches
      newRules.value = newRules.value.filter(rule => {
        const matches = newRuleMatches.value.get(rule.id) || []
        return matches.length > 0
      })
    }

    function clearNewRules() {
      // Clear new rules when starting a new import
      newRules.value = []
    }

    function handleCombinedRulesSkip() {
      // Skip rules review and go to complete step
      step.value = 5
    }

    /**
     * Centralized function to compute all rule matches with proper priority handling
     * This ensures no transaction double-counting and respects rule priorities
     */
    function computeAllRuleMatches() {
      if (!allTransactions.value || allTransactions.value.length === 0) {
        console.log('computeAllRuleMatches: No transactions to match')
        return
      }

      console.log('computeAllRuleMatches: Computing matches for all rule types')
      
      // Get all rules from different sources
      const existingRules = usedRules.value || []
      const newRulesList = newRules.value || []
      const autoRulesList = autoRules.value?.rules?.filter(r => !r.applied) || []
      
      console.log('computeAllRuleMatches: Rule counts', {
        existing: existingRules.length,
        new: newRulesList.length,
        auto: autoRulesList.length,
        totalTransactions: allTransactions.value.length
      })

      // Combine all rules and sort by priority
      const allRules = [
        ...existingRules.map(rule => ({ ...rule, source: 'existing' })),
        ...newRulesList.map(rule => ({ ...rule, source: 'new' })),
        ...autoRulesList.map(rule => ({ ...rule, source: 'auto' }))
      ].sort((a, b) => {
        // Sort by priority (highest first)
        if (b.priority !== a.priority) return b.priority - a.priority
        // If same priority, most recent wins
        const aTime = new Date(a.updated_at || a.created_at || 0).getTime()
        const bTime = new Date(b.updated_at || b.created_at || 0).getTime()
        return bTime - aTime
      })

      console.log('computeAllRuleMatches: Combined and sorted rules', allRules.length)

      // Use centralized rule matching logic
      const result = applyRulesWithDetails(allTransactions.value, allRules)
      
      // Separate matches by rule source
      existingRuleMatches.value.clear()
      newRuleMatches.value.clear()
      autoRuleMatches.value.clear()
      
      for (const [ruleId, matchingTransactions] of result.ruleMatches) {
        const rule = allRules.find(r => r.id === ruleId)
        if (!rule) continue
        
        switch (rule.source) {
          case 'existing':
            existingRuleMatches.value.set(ruleId, matchingTransactions)
            break
          case 'new':
            newRuleMatches.value.set(ruleId, matchingTransactions)
            break
          case 'auto':
            autoRuleMatches.value.set(ruleId, matchingTransactions)
            break
        }
      }
      
      console.log('computeAllRuleMatches: Match results', {
        existingMatches: existingRuleMatches.value.size,
        newMatches: newRuleMatches.value.size,
        autoMatches: autoRuleMatches.value.size
      })
    }

    async function handleSaveRules() {
      processing.value = true
      
      try {
        // Collect all rules with hasChanges: true from all sources
        const allRulesToSave = []
        
        // Get edited pre-existing rules
        const editedExistingRules = usedRules.value.filter(rule => rule.hasChanges)
        allRulesToSave.push(...editedExistingRules.map(rule => ({ ...rule, isNew: false })))
        
        // Get new rules
        const newRulesToSave = newRules.value.filter(rule => rule.hasChanges)
        allRulesToSave.push(...newRulesToSave.map(rule => ({ ...rule, isNew: true })))
        
        // Get auto-generated rules that haven't been applied yet (they should be saved)
        const autoRulesToSave = autoRules.value?.rules?.filter(rule => !rule.applied) || []
        allRulesToSave.push(...autoRulesToSave.map(rule => ({ ...rule, isNew: true })))
        
        console.log('handleSaveRules: Saving rules to backend:', allRulesToSave)
        
        // Save all rules with changes
        for (const rule of allRulesToSave) {
          try {
            if (rule.isNew) {
              // Remove flags before sending to backend
              const { hasChanges, isNew, ...ruleToSave } = rule
              const savedRule = await api.createRule(ruleToSave)
              console.log('handleSaveRules: Created new rule:', savedRule)
              
              // Mark auto-generated rules as applied
              if (autoRules.value?.rules) {
                const autoRule = autoRules.value.rules.find(r => r.id === rule.id)
                if (autoRule) {
                  autoRule.applied = true
                }
              }
            } else {
              // Remove flags before sending to backend
              const { hasChanges, isNew, ...ruleToSave } = rule
              await api.updateRule(rule.id, ruleToSave)
              console.log('handleSaveRules: Updated existing rule:', rule.id)
            }
          } catch (error) {
            console.error('Error saving rule:', error)
            // Continue with other rules even if one fails
          }
        }
        
        // Navigate to Transaction Review step
        step.value = 4
      } catch (error) {
        console.error('Error in handleSaveRules:', error)
        alert('Error saving rules: ' + error.message)
      } finally {
        processing.value = false
      }
    }

    async function handleImportTransactions() {
      // Use existing commitAllImports() logic
      await commitAllImports()
    }

    return {
      // Props
      props,
      // Reactive data
      newAccount,
      step,
      creating,
      createError,
      createForm,
      editingAccount,
      editAccountName,
      editError,
      updating,
      deleteDialog,
      accountToDelete,
      deleting,
      deleteError,
      files,
      fileAnalysis,
      filesByAccount,
      previewsByAccount,
      usedRules,
      autoRules,
      newRules,
      allTransactions,
      existingRuleMatches,
      newRuleMatches,
      autoRuleMatches,
      isDragOver,
      processing,
      currentCategoryStep,
      categorySteps,
      categoryStepNames,
      accountNameRules,
      totalFiles,
      totalTransactions,
      currentCategoryTransactions,
      hasMoreCategories,
      hasPreviousCategories,
      allFilesAssigned,
      getCurrentAccountId,
      getAccountName,
      getFileFormat,
      addAccount,
      startEdit,
      cancelEdit,
      saveAccount,
      confirmDelete,
      deleteAccount,
      formatDate,
      handleDragOver,
      handleDragLeave,
      handleDrop,
      handleFileSelect,
      analyzeFiles,
      removeFile,
      reassignFile,
      processAllFiles,
      nextCategory,
      previousCategory,
      commitAllImports,
      resetImport,
      handleRulesCommit,
      handleRulesCancel,
      handleRefreshRules,
      handleRulesRefresh,
      addNewRule,
      clearNewRules,
      handleCombinedRulesSkip,
      handleSaveRules,
      handleImportTransactions,
      goBackToRules: () => { step.value = 3 }
    }
  }
}
