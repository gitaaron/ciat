#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  file: null,
  output: null,
  format: 'json', // json, csv, table
  minFrequency: 2,
  help: false
};

// Parse arguments
for (let i = 0; i < args.length; i++) {
  const arg = args[i];
  switch (arg) {
    case '--file':
    case '-f':
      options.file = args[++i];
      break;
    case '--output':
    case '-o':
      options.output = args[++i];
      break;
    case '--format':
      options.format = args[++i];
      break;
    case '--min-frequency':
      options.minFrequency = parseInt(args[++i]) || 2;
      break;
    case '--help':
    case '-h':
      options.help = true;
      break;
  }
}

if (options.help) {
  console.log(`
Usage: node generate-auto-rules.js --file <path> [options]

Generate autogenerated categorization rules from transaction files.

Arguments:
  -f, --file <path>              Path to transaction file (CSV or QFX)
  -o, --output <path>            Output file path (optional, prints to console if not specified)
  --format <format>              Output format: json, csv, table (default: json)
  --min-frequency <number>       Minimum frequency threshold (default: 2)
  -h, --help                     Show this help message

Examples:
  node generate-auto-rules.js --file transactions.csv
  node generate-auto-rules.js --file transactions.qfx --format table
  node generate-auto-rules.js --file data.csv --output rules.json --format json
  node generate-auto-rules.js --file data.csv --min-frequency 3

Supported file formats:
  - CSV files (.csv) - comma or tab delimited
  - QFX files (.qfx) - Quicken Financial Exchange format
`);
  process.exit(0);
}

if (!options.file) {
  console.error('‚ùå Error: --file argument is required');
  console.log('Use --help for usage information');
  process.exit(1);
}

if (!fs.existsSync(options.file)) {
  console.error(`‚ùå Error: File not found: ${options.file}`);
  process.exit(1);
}

// Validate format
const validFormats = ['json', 'csv', 'table'];
if (!validFormats.includes(options.format)) {
  console.error(`‚ùå Error: Invalid format "${options.format}". Valid formats: ${validFormats.join(', ')}`);
  process.exit(1);
}


// Validate frequency threshold
if (options.minFrequency < 1) {
  console.error('‚ùå Error: min-frequency must be at least 1');
  process.exit(1);
}

// Create a temporary script to run the ES modules
const tempScriptPath = path.join(__dirname, 'temp-auto-rules.mjs');

const tempScript = `
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Import backend modules
const { parseTransactionsCSV } = await import('../backend/src/utils/parseCSV.js');
const { parseTransactionsQFX } = await import('../backend/src/utils/parseQFX.js');
const { detectFileFormat, isSupportedFormat } = await import('../backend/src/utils/fileFormatDetector.js');
const { generateAutoRules } = await import('../backend/src/categorizer/autoRuleGenerator.js');

async function main() {
  const args = process.argv.slice(2);
  const filePath = args[0];
  const format = args[1];
  const minConfidence = parseFloat(args[2]);
  const minFrequency = parseInt(args[3]);
  const maxRules = parseInt(args[4]);
  const outputFormat = args[5];
  const outputPath = args[6];

  try {
    console.log(\`üîç Analyzing transaction file: \${filePath}\`);
    
    // Read file
    const fileBuffer = fs.readFileSync(filePath);
    const fileName = path.basename(filePath);
    
    // Detect file format
    const detectedFormat = detectFileFormat(fileName, fileBuffer);
    
    if (!isSupportedFormat(detectedFormat)) {
      console.error(\`‚ùå Error: Unsupported file format: \${detectedFormat}. Supported formats: CSV, QFX\`);
      process.exit(1);
    }
    
    console.log(\`üìÑ File format detected: \${detectedFormat.toUpperCase()}\`);
    
    // Parse transactions
    let transactions;
    if (detectedFormat === 'csv') {
      transactions = parseTransactionsCSV(fileBuffer);
    } else if (detectedFormat === 'qfx') {
      transactions = await parseTransactionsQFX(fileBuffer);
    }
    
    console.log(\`üìä Parsed \${transactions.length} transactions\`);
    
    if (transactions.length === 0) {
      console.log('‚ö†Ô∏è  No transactions found in file');
      process.exit(0);
    }
    
    // Add required fields for auto rule generation
    const processedTransactions = transactions.map((tx, index) => ({
      ...tx,
      id: \`temp_\${index}\`,
      hash: \`temp_hash_\${index}\`,
      category: tx.category || null,
      mcc: tx.mcc || null,
      merchant_id: tx.merchant_id || null
    }));
    
    console.log(\`ü§ñ Generating auto rules...\`);
    console.log(\`   Min frequency: \${minFrequency}\`);
    
    // Generate auto rules
    const result = generateAutoRules(processedTransactions);
    
    console.log(\`‚úÖ Generated \${result.rules.length} auto rules\`);
    
    if (result.rules.length === 0) {
      console.log('‚ÑπÔ∏è  No rules could be generated with the current thresholds');
      console.log('   Try lowering --min-frequency');
      process.exit(0);
    }
    
    // Display statistics
    console.log('\\nüìà Rule Statistics:');
    console.log(\`   Total rules: \${result.rules.length}\`);
    console.log(\`   Frequency rules: \${result.stats.frequencyRules}\`);
    console.log(\`   MCC rules: \${result.stats.mccRules}\`);
    console.log(\`   Merchant ID rules: \${result.stats.merchantIdRules}\`);
    console.log(\`   Recurring rules: \${result.stats.recurringRules}\`);
    console.log(\`   Marketplace rules: \${result.stats.marketplaceRules}\`);
    console.log(\`   Exception rules: \${result.stats.exceptionRules}\`);
    
    // Format output
    let output;
    switch (outputFormat) {
      case 'json':
        output = JSON.stringify({
          metadata: {
            sourceFile: filePath,
            totalTransactions: transactions.length,
            generatedAt: new Date().toISOString(),
            config: {
              minConfidence: minConfidence,
              minFrequency: minFrequency,
              maxRules: maxRules
            }
          },
          statistics: result.stats,
          rules: result.rules
        }, null, 2);
        break;
        
      case 'csv':
        const csvHeader = 'Type,Pattern,Category,Frequency,Priority,Source,Explanation';
        const csvRows = result.rules.map(rule => [
          rule.type,
          \`"\${rule.pattern}"\`,
          rule.category || 'null',
          rule.frequency,
          rule.priority,
          rule.source,
          \`"\${rule.explain}"\`
        ].join(','));
        output = [csvHeader, ...csvRows].join('\\n');
        break;
        
      case 'table':
        output = formatRulesAsTable(result.rules);
        break;
    }
    
    // Output results
    if (outputPath) {
      fs.writeFileSync(outputPath, output);
      console.log(\`\\nüíæ Rules saved to: \${outputPath}\`);
    } else {
      console.log('\\n' + '='.repeat(80));
      console.log('GENERATED AUTO RULES');
      console.log('='.repeat(80));
      console.log(output);
    }
    
    // Show sample rules
    console.log('\\nüîç Sample Rules (Top 5 by Priority):');
    result.rules.slice(0, 5).forEach((rule, index) => {
      console.log(\`\\n\${index + 1}. \${rule.type.toUpperCase()} Rule\`);
      console.log(\`   Pattern: "\${rule.pattern}"\`);
      console.log(\`   Category: \${rule.category || 'null'}\`);
      console.log(\`   Frequency: \${rule.frequency}\`);
      console.log(\`   Priority: \${rule.priority}\`);
      console.log(\`   Source: \${rule.source}\`);
      console.log(\`   Explanation: \${rule.explain}\`);
    });
    
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

function formatRulesAsTable(rules) {
  const maxPatternLength = Math.max(20, ...rules.map(r => r.pattern.length));
  const maxCategoryLength = Math.max(10, ...rules.map(r => (r.category || 'null').length));
  const maxSourceLength = Math.max(10, ...rules.map(r => r.source.length));
  
  const header = [
    'Type'.padEnd(8),
    'Pattern'.padEnd(maxPatternLength),
    'Category'.padEnd(maxCategoryLength),
    'Freq'.padEnd(5),
    'Priority'.padEnd(8),
    'Source'.padEnd(maxSourceLength)
  ].join(' | ');
  
  const separator = '-'.repeat(header.length);
  
  const rows = rules.map(rule => [
    rule.type.padEnd(8),
    rule.pattern.padEnd(maxPatternLength),
    (rule.category || 'null').padEnd(maxCategoryLength),
    rule.frequency.toString().padEnd(5),
    rule.priority.toString().padEnd(8),
    rule.source.padEnd(maxSourceLength)
  ].join(' | '));
  
  return [header, separator, ...rows].join('\\n');
}

main().catch(error => {
  console.error('‚ùå Unexpected error:', error);
  process.exit(1);
});
`;

async function main() {
  try {
    // Write temporary script
    fs.writeFileSync(tempScriptPath, tempScript);
    
    // Convert relative path to absolute path if needed
    let filePath = options.file;
    if (!path.isAbsolute(filePath)) {
      // If it's a relative path, resolve it relative to the project root
      const projectRoot = path.join(__dirname, '..');
      filePath = path.resolve(projectRoot, filePath);
    }
    
    // Run the temporary script with arguments
    const command = `node "${tempScriptPath}" "${filePath}" "${options.format}" ${options.minConfidence} ${options.minFrequency} ${options.maxRules} "${options.format}" ${options.output ? `"${options.output}"` : '""'}`;
    
    execSync(command, { stdio: 'inherit', cwd: __dirname });
    
  } catch (error) {
    console.error('‚ùå Error running script:', error.message);
    process.exit(1);
  } finally {
    // Clean up temporary file
    if (fs.existsSync(tempScriptPath)) {
      fs.unlinkSync(tempScriptPath);
    }
  }
}

// Run the script
main().catch(error => {
  console.error('‚ùå Unexpected error:', error);
  process.exit(1);
});